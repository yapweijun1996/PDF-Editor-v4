'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var node_events = require('node:events');
var path = require('node:path');
var process = require('node:process');
var cheerio = require('cheerio');
var fs = require('node:fs');
var Parser = require('htmlparser2');
var fastXmlParser = require('fast-xml-parser');
var node_util = require('node:util');
require('ansi-regex');
var chalk$1 = require('chalk');

function _interopNamespaceDefault(e) {
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n.default = e;
	return Object.freeze(n);
}

var cheerio__namespace = /*#__PURE__*/_interopNamespaceDefault(cheerio);

/**
 * @fileoverview Utilities for the CLI.
 */

const supportsColor =
	chalk$1.supportsColor &&
	!('NO_COLOR' in process.env) &&
	!('SVGLINT_NO_COLOR' in process.env);

const chalk = supportsColor ? new chalk$1.Chalk() : new chalk$1.Chalk({level: 0});

process.stdout.columns || 80;
Object.freeze({
	// Logs
	debug: Object.freeze({
		symbol: 'd',
		color: chalk.gray.dim.bold,
	}),
	log: Object.freeze({
		symbol: 'i',
		color: chalk.blue.bold,
	}),

	// Lintings
	linting: Object.freeze({
		symbol: null,
		color: chalk.gray.dim,
	}),
	success: Object.freeze({
		symbol: 'âœ“',
		color: chalk.green.bold,
	}),
	warn: Object.freeze({
		symbol: '!',
		color: chalk.yellow.bold,
	}),
	error: Object.freeze({
		symbol: 'x',
		color: chalk.red.bold,
	}),
	exception: Object.freeze({
		symbol: '!!!',
		color: chalk.bgRed.bold,
	}),
});

/**
 * @fileoverview Exposes the logger we should use for displaying info.
 * If called using the JS API, this will be `console` with prefixes.
 * If called using the CLI, this will be our own custom logger.
 */

const CONSOLE_COLORS = Object.freeze({
	debug: chalk.dim.gray,
	log: chalk.blue,
	warn: chalk.yellow,
	error: chalk.red,
});
const LEVELS = Object.freeze({
	debug: 0,
	log: 1,
	warn: 2,
	error: 3,
});
const METHODS = ['debug', 'log', 'warn', 'error'];

// Logger-global variables
let isCLI = false;
let level = LEVELS.log;

// Create a prefixing & colorizing wrapper around console for use in non-CLIs
const wrappedConsole = Object.create(console);
for (const method of METHODS) {
	// eslint-disable-next-line unicorn/prefer-logical-operator-over-ternary
	const color = CONSOLE_COLORS[method] ? CONSOLE_COLORS[method] : (v) => v;
	wrappedConsole[method] = (prefix, arguments_) => {
		// eslint-disable-next-line no-useless-call, no-console
		console[method].apply(console, [color('[' + prefix + ']'), ...arguments_]);
	};
}

// Create a simple collector & emitter of messages for use in CLIs
class CliConsole extends node_events.EventEmitter {
	constructor() {
		super();
		/** The messages that have been emitted so far.
		 * @type {Array<{ prefix: String, args: Array, type: String }>} */
		this.messages = [];
		for (const method of METHODS) {
			this[method] = (prefix, arguments_) => {
				const message = {
					prefix: prefix.replace(/^SVGLint ?/, ''),
					args: arguments_,
					type: method,
				};
				this.messages.push(message);
				this.emit('msg', message);
			};
		}
	}
}
CliConsole.prototype.EVENTS = METHODS;
const cliConsole = new CliConsole();

const Logger = function (prefix) {
	prefix = 'SVGLint' + (prefix ? ' ' + prefix : '');
	const logger = {};
	for (const method of METHODS) {
		logger[method] = function (...arguments_) {
			if (level > LEVELS[method]) {
				return;
			}

			if (isCLI) {
				// eslint-disable-next-line no-useless-call
				cliConsole[method].call(cliConsole, prefix, arguments_);
			} else {
				// eslint-disable-next-line no-useless-call
				wrappedConsole[method].call(wrappedConsole, prefix, arguments_);
			}
		};
	}

	return logger;
};

Logger.cliConsole = cliConsole;
Logger.setCLI = (value) => {
	isCLI = value;
};

Logger.setLevel = (value) => {
	level = value;
};

Logger.LEVELS = LEVELS;
Logger.colorize = supportsColor
	? (value) => node_util.inspect(value, true, 2, true)
	: (value) => value;

/**
 * @fileoverview The SVG -> AST parser.
 * This handles turning an SVG source into an AST representing it.
 * It uses htmlparser2 to parse the source, which it gathers from either
 *   a string or a file.
 */

/**
 * Parses an SVG source into an AST
 * @param {String} source The source to parse
 * @returns {AST} The parsed AST
 */
function parseSource(source) {
	return normalizeAST(sourceToAST(source), source);
}

/**
 * Clones an AST by re-parsing it's source
 * @param {AST} ast The AST to clone
 * @returns {AST} The cloned AST
 */
function clone(ast) {
	// @ts-ignore
	return parseSource(ast.source);
}

/**
 * Parses the content of a file into an AST
 * @param {String} file The path of the file in question
 * @returns {Promise<AST>} The parsed AST
 */
function parseFile(file) {
	const filePath = path.isAbsolute(file)
		? file
		: path.join(process.cwd(), file);
	return new Promise((resolve, reject) => {
		// eslint-disable-next-line n/prefer-promises/fs
		fs.readFile(filePath, 'utf8', (error, data) => {
			if (error) {
				return reject(error);
			}

			try {
				return resolve(parseSource(data));
			} catch (error_) {
				return reject(error_);
			}
		});
	});
}

/**
 * @typedef {Object<string,string>} Attributes
 */
/**
 * @typedef Node
 * @property {String} type The type of node
 * @property {Node} next The next sibling
 * @property {Node} prev The previous sibling
 * @property {Node} parent The parent of the node
 * @property {Number} startIndex The string index at which the element starts
 * @property {Number} endIndex The string index at which the element ends
 * @property {Number} lineNum The line number at which the element starts
 * @property {Number} columnNum The index in the line at which the element starts
 *
 * @property {Attributes} [attribs] An object of attributes on the Node
 * @property {AST} [children] The children of the Node
 * @property {String} [data] If type==="text", the content of the Node
 * @property {String} [name] If type!=="text", the tag name
 */
/**
 * @typedef ASTShape
 * @property {String} source The source that generated the AST
 *
 * @typedef {Node[] & ASTShape} AST
 * An AST representing an SVG document (or a list of children).
 */

/**
 * Parses an SVG source code into an AST.
 * @param {String} source
 * @returns {AST} The parsed AST
 */
function sourceToAST(source) {
	// @ts-ignore
	const outp = Parser.parseDOM(source, {
		withStartIndices: true,
		withEndIndices: true,
		xmlMode: true,
	});
	return outp;
}

/**
 * Normalizes a Node to the format we want.
 * Currently translates the startIndex to a line number+index.
 * == MODIFIES THE NODE IN-PLACE! ==
 * @param {Node} node The node to normalize
 * @param {String} source The string the AST was generated from
 */
function normalizeNode(node, source) {
	// Calculate the distance from node start to line start
	const lineStart =
		source.lastIndexOf(
			'\n',
			node.startIndex +
				// Make sure newline text nodes are set to start on the proper line
				(node.type === 'text' && node.data.startsWith('\n') ? -1 : 0),
		) + 1;
	node.columnNum = node.startIndex - lineStart;

	// Calculate the line number
	let numberLines = 0;
	let columnNumber = lineStart;
	while (
		(columnNumber = source.lastIndexOf('\n', columnNumber - 1)) !== -1 &&
		columnNumber > 0
	) {
		++numberLines;
	}

	node.lineNum = numberLines;
	return node;
}

/**
 * Normalizes the AST returned by htmlparser2 to the format we want.
 * Currently translates the startIndex to a line number+index.
 * == MODIFIES THE AST IN-PLACE! ==
 * @param {AST} ast The AST to normalize
 * @param {String} source The source the AST was generated from
 * @returns {AST} The normalized AST
 */
function normalizeAST(ast, source) {
	const handleNode = (node) => {
		normalizeNode(node, source);
		if (node.children) {
			for (const child of node.children) {
				handleNode(child);
			}
		}
	};

	for (const child of ast) {
		handleNode(child);
	}

	// @ts-ignore
	ast.source = source;
	return ast;
}

/**
 * @fileoverview The object that rules use to report errors, warnings and messages.
 */

/** @typedef {import('cheerio').Cheerio<import('domhandler').Document>} Cheerio */
/** @typedef {import("./parse.js").AST} AST */
/** @typedef {import("./parse.js").Node} Node */

/**
 * @typedef {Object} Result
 * @property {String} message The message as a single string, suitable for human consumption
 * @property {String} reason The message as a single string
 * @property {"error"|"warn"|"exception"} type The type of result
 * @property {String} [stacktrace] If Result is related to a node, a human-suitable string showing the related part of the file
 * @property {number} [line] If Result is related to a node, the related line in the file
 * @property {number} [column] If Result is related to a node, the related column in the file
 * @property {any[]} _message The original message, as given by the rule
 * @property {Node} [_node] If Result is related to a node, the related node
 * @property {AST} [_ast] If Result is related to a node, the related AST
 */

/**
 * Generates a Result from the arguments given to .error()/.warn()/.log().
 * Mostly involves formatting the message that should be shown when logged.
 * @param {any[]|any} message The message of the result, in console.log format
 * @param {"error"|"warn"|"exception"} type The type of message
 * @param {Node|Cheerio} [node] If the error is related to a node, the related node
 * @param {AST} [ast] If the error is related to a node, the related AST
 * @returns {Result}
 */
function generateResult(message, type, node, ast) {
	const _message = Array.isArray(message) ? message : [message];
	const outp = {
		message,
		reason: message,
		_message,
		_node: node,
		_ast: ast,
		type,
	};
	if (message instanceof Error) {
		outp.message = message.stack || message.toString();
		outp.reason = message.toString();
	}

	if (node) {
		// @ts-ignore
		outp.message += `\n  At node ${chalk.bold('<' + node.name + '>')} (${node.lineNum}:${node.columnNum})`;
		outp.reason += ' at node <' + node.name + '>';
		outp.line = node.lineNum;
		outp.column = node.columnNum;
	}

	// @ts-ignore
	return outp;
}

/**
 * The Reporter class is used by rules to report errors, warnings and exceptions.
 * It collects the messages and provides a way to access them.
 * @extends EventEmitter
 * @interface Reporter
 * @property {String} name The name of this reporter
 */
class Reporter extends node_events.EventEmitter {
	/**
	 * @param {String} name The name of this reporter
	 */
	constructor(name) {
		super();
		this.name = name;
		this.logger = Logger(`rprt:${this.name}`);
		/** @type {Result[]} */
		this.messages = [];

		this.hasExceptions = false;
		this.hasWarns = false;
		this.hasErrors = false;
	}

	/**
	 * Reports that an exception occurred during rule processing.
	 * This doesn't change the current linting result, but is important to show
	 *   to users as it indicates that the linting result cannot be trusted.
	 * @param {Error} e The exception that occurred.
	 */
	exception(event) {
		this.logger.debug('Exception reported:', event);
		this.emit('exception', event);
		this.hasExceptions = true;
		this.messages.push(generateResult(event, 'exception'));
	}

	/**
	 * Reports that an error was found during linting.
	 * @param {any[]|any} message The message of the result, in console.log format
	 * @param {Node|Cheerio} [node] If the error is related to a node, the related node
	 * @param {AST} [ast] If the error is related to a node, the AST of the file
	 */
	error(message, node, ast) {
		this.logger.debug(
			'Error reported:',
			JSON.stringify(message),
			Boolean(node),
		);
		const result = generateResult(message, 'error', node, ast);
		this.hasErrors = true;
		this.messages.push(result);
	}

	/**
	 * Reports that a warning was found during linting.
	 * @param {any[]|any} message The message of the result, in console.log format
	 * @param {Node|Cheerio} [node] If the warning is related to a node, the related node
	 * @param {AST} [ast] If the warning is related to a node, the AST of the file
	 */
	warn(message, node, ast) {
		this.logger.debug('Warn reported:', JSON.stringify(message), Boolean(node));
		const result = generateResult(message, 'warn', node, ast);
		this.hasWarns = true;
		this.messages.push(result);
	}
}

/**
 * @fileoverview The main linting file.
 * This is the object responsible for the actual linting of each file.
 * Each instance represents a single file being linted, including results and
 *   current state.
 * It receives the parsed AST and rules from ../svglint.js, and then runs each
 *   rule and gathers the results.
 */

/** @typedef {import("./parse.js").AST} AST */
/** @typedef {import("./parse.js").Node} Node */
/** @typedef {import("../svglint.js").NormalizedRules} NormalizedRules */
/** @typedef {import("../svglint.js").Fixtures} Fixtures */
/** @typedef {import("../svglint.js").FixturesConfig} FixturesConfig */

const STATES = Object.freeze({
	ignored: 'ignored',
	linting: 'linting',
	success: 'success',
	warn: 'warn',
	error: 'error',
});

/**
 * Represents a single file that is being linted.
 * Contains the status and potential result of the linting.
 * @event rule Emitted when a rule is finished
 * @event done Emitted when the linting is done
 */
class Linting extends node_events.EventEmitter {
	/**
	 * Creates and starts a new linting.
	 * @param {String} file The file to lint
	 * @param {AST} ast The AST of the file
	 * @param {NormalizedRules} rules The rules to lint by
	 * @param {FixturesConfig} fixturesLoader The fixtures loader
	 */
	constructor(file, ast, rules, fixturesLoader) {
		super();
		/** The AST of the file */
		this.ast = ast;
		/** The rules we use for linting */
		this.rules = rules;
		/** Fixtures for the linting */
		this.fixturesLoader = fixturesLoader;
		/** The path to the file */
		this.path = file;
		/** The current state of the linting */
		this.state = STATES.linting;
		/** If false, the linting has at least one rule that threw when executing */
		this.valid = true;
		/** The name used for logging/human consumption */
		this.name = file ? path.relative(process.cwd(), file) : 'API';
		/** The Reporters for each rule we've linted
		 * @type Object<string,Reporter|Reporter[]> */
		this.results = {};
		/** The logger used to show debugs */
		this.logger = Logger(`lint:${this.name}`);
	}

	/**
	 * Starts the linting.
	 * Errors from rules are safely caught and logged as exceptions from the rule.
	 */
	lint() {
		this.state = STATES.linting;

		// Keep track of when every rule has finished
		const ruleNames = Object.keys(this.rules);
		if (ruleNames.length === 0) {
			this.logger.debug('No rules to lint, finishing');
			this.state = STATES.success;
			Promise.resolve().then(() => this.emit('done'));
			return;
		}

		this._maybeLoadFixtures((fixtures) => {
			this.logger.debug('Started linting');
			this.logger.debug('  Rules:', ruleNames);

			this.activeRules = ruleNames.length;

			// Start every rule
			for (const ruleName of ruleNames) {
				const ast = clone(this.ast);
				const $ = cheerio__namespace
					.load('<root></root>', {xmlMode: true})('root')
					// @ts-ignore
					.append(ast);

				/** @type {Function|Function[]} */
				const rule = this.rules[ruleName];
				if (Array.isArray(rule)) {
					/** @type {Reporter[]} */
					const results = [];
					let activeRules = rule.length;
					for (const [i, r] of rule.entries()) {
						this._executeRule(
							r,
							`${ruleName}-${i + 1}`,
							$,
							ast,
							fixtures,
							(result) => {
								results[i] = result;
								if (--activeRules <= 0) {
									this._onRuleFinish(ruleName, results);
								}
							},
						);
					}

					if (rule.length === 0) {
						Promise.resolve().then(() => {
							this._onRuleFinish(ruleName, this._generateReporter(ruleName));
						});
						this.logger.debug(
							'Rule had no configs',
							Logger.colorize(ruleName),
						);
					}
				} else {
					this._executeRule(rule, ruleName, $, ast, fixtures, (result) => {
						this._onRuleFinish(ruleName, result);
					});
				}
			}
		});
	}

	/**
	 * Handles a rule finishing.
	 * @param {String} ruleName The name of the rule that just finished
	 * @param {Reporter|Reporter[]} reporter The reporter containing rule results
	 * @emits rule
	 * @private
	 */
	_onRuleFinish(ruleName, reporter) {
		this.logger.debug('Rule finished', Logger.colorize(ruleName));
		this.emit('rule', {
			name: ruleName,
			result: reporter,
		});
		this.results[ruleName] = reporter;

		--this.activeRules;
		if (this.activeRules === 0) {
			this.state = this._calculateState();
			this.logger.debug(
				'Linting finished with status',
				Logger.colorize(this.state),
			);
			this.emit('done');
		}
	}

	/**
	 * Calculates the current state from this.results.
	 * @returns One of the valid states
	 */
	_calculateState() {
		let state = STATES.success;
		// eslint-disable-next-line guard-for-in
		for (const k in this.results) {
			const result = this.results[k];
			if (Array.isArray(result)) {
				if (result.some((item) => item.hasErrors || item.hasExceptions)) {
					return STATES.error;
				}

				if (result.some((item) => item.hasWarns)) {
					state = STATES.warn;
				}
			} else {
				if (result.hasErrors || result.hasExceptions) {
					return STATES.error;
				}

				if (result.hasWarns) {
					state = STATES.warn;
				}
			}
		}

		return state;
	}

	/**
	 * Generates a Reporter for use with this file.
	 * Remember to call .done() on it.
	 * @param {String} ruleName The name of the rule that this reporter is used for
	 * @returns {Reporter} The generated reporter
	 * @private
	 */
	_generateReporter(ruleName) {
		const reporter = new Reporter(ruleName);
		reporter.once('exception', () => {
			this.valid = false;
		});
		return reporter;
	}

	/**
	 * Executes a rule function.
	 * @param {Function} rule The loaded rule
	 * @param {String} reporterName The name to give the reporter
	 * @param {$} $ The cheerio instance to use for the rule
	 * @param {AST} ast The AST to use for the rule
	 * @param {any} fixtures The fixtures to use for the rule
	 * @param {() => Reporter} onDone Function to call once the rule is done
	 */
	// eslint-disable-next-line max-params
	_executeRule(rule, reporterName, $, ast, fixtures, onDone) {
		// Gather results from the rule through a reporter
		const reporter = this._generateReporter(reporterName);
		// Execute the rule, potentially waiting for async rules
		// also handles catching errors from the rule
		const injected = {filepath: this.path};
		if (fixtures !== undefined) {
			// If fixtures are provided, inject them into the rule.
			// Note that fixtures are mutable. Rules should not mutate them.
			injected.fixtures = fixtures;
		}

		Promise.resolve()
			.then(() => rule(reporter, $, ast, injected))
			.catch((error) => reporter.exception(error))
			.then(() => onDone(reporter));
	}

	/**
	 * Maybe loads fixtures for the linting.
	 * @param {() => Fixtures|undefined} onDone
	 */
	_maybeLoadFixtures(onDone) {
		if (this.fixturesLoader) {
			this.logger.debug('Resolving fixtures for linting');
			const ast = clone(this.ast);
			const $ = cheerio__namespace
				.load('<root></root>', {xmlMode: true})('root')
				// @ts-ignore
				.append(ast);

			// Resolve fixtures
			const reporter = this._generateReporter('fixtures');
			Promise.resolve()
				.then(() =>
					this.fixturesLoader(reporter, $, ast, {filepath: this.path}),
				)
				.catch((error) => reporter.exception(error))
				.then((fixtures) => {
					if (reporter.hasErrors || reporter.hasExceptions) {
						this.state = STATES.error;
						this.logger.debug(
							'Fixtures rule aborted execution with status',
							Logger.colorize(this.state),
						);
						this.emit('done');
					} else {
						if (reporter.hasWarns) {
							this.state = STATES.warn;
						}

						onDone(fixtures);
					}
				});
		} else {
			this.logger.debug('No fixtures loader detected');
			onDone(undefined);
		}
	}
}

// eslint-disable-next-line no-multi-assign
Linting.STATES = Linting.prototype.STATES = STATES;

function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case '../rules/attr.js': return Promise.resolve().then(function () { return attr; });
    case '../rules/custom.js': return Promise.resolve().then(function () { return custom$1; });
    case '../rules/elm.js': return Promise.resolve().then(function () { return elm$1; });
    case '../rules/valid.js': return Promise.resolve().then(function () { return valid$1; });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }

/**
 * @fileoverview Turns a rule name into a module import.
 * Can be extended to use a cache if we have to do heavier processing when
 *   loading a rule.
 * Currently NodeJS' import cache is just fine.
 */

/**
 * @typedef RuleModule
 * @property {Function} generate When given a config, returns a linting function
 */

/**
 * Finds and imports a rule from its name.
 * If the rule is named in the format "a/b" then the rule will be loaded from
 *   the package "svglint-plugin-a/b".
 * If the rule name does not contain a slash then it will be loaded from the
 *   built-in SVGLint rules.
 * @param {String} ruleName The name of the rule
 * @returns {Promise<RuleModule>} Resolves to the function exported by the rule if found.
 */
async function ruleLoader(ruleName) {
	const fileName = ruleName.endsWith('.js') ? ruleName : ruleName + '.js';
	const isExternal = ruleName.includes('/');
	const module = await (isExternal
		? import(`svglint-plugin-${ruleName}`)
		: __variableDynamicImportRuntime1__(`../rules/${fileName.slice(0, -3)}.js`));

	return module.default;
}

/**
 * @fileoverview The SVGLint entry file.
 * This is the publicly exposed JS API, which the CLI also uses.
 * It exposes .lintSource() and .lintFile().
 * Main responsibility is handling the consumer<->Linting communication,
 *   and converting the user-provided config into an object of rules.
 */

const logger$4 = Logger('');

/** @typedef {import("./lib/parse.js").AST} AST */
/** @typedef {import("./lib/rule-loader.js").RuleModule} RuleModule */
/** @typedef {import("./rules/elm.js").ElmConfig} ElmConfig */
/** @typedef {import("./rules/attr.js").AttrConfig} AttrConfig */
/** @typedef {import("./rules/custom.js").CustomConfig} CustomConfig */
/** @typedef {import("./rules/custom.js").Info} Info */

/**
 * @typedef RulesConfig
 * An object with each key representing a rule name, and each value representing
 *   a rule config.
 * If the rule config is set to `false`, then the rule is disabled (useful for
 *   e.g. overwriting presets).
 * @property {ElmConfig} [elm={}]
 * @property {Array<AttrConfig>} [attr=[]]
 * @property {Array<CustomConfig>} [custom=[]]
 */
/**
 * @typedef {Object<string,Function|Function[]>} NormalizedRules
 * The RulesConfig after being normalized - each function is a rule.
 */
/**
 * @typedef {String[]} IgnoreList
 * An array of strings, each of which is a blob that represents files to ignore.
 * If any blob matches a file, the file is not linted.
 */

/**
 * @callback FixturesConfig
 * @param {Reporter} reporter The reporter to report to
 * @param {Cheerio} $ A cheerio representation of the document
 * @param {AST} ast The AST of the document, which we should pass to reporter
 * @param {{filepath: string}} info Info related to the current file being linted
 */

/**
 * @typedef Config
 * @property {RulesConfig} [rules={}] The rules to lint by
 * @property {IgnoreList} [ignore=[]] The blobs representing which files to ignore
 * @property {FixturesConfig} [fixtures] The fixtures function to inject data
 */
/**
 * @typedef NormalizedConfig
 * @property {NormalizedRules} rules The rules to lint by
 * @property {IgnoreList} ignore The blobs representing which files to ignore
 * @property {FixturesConfig} fixtures The fixtures function to inject data
 */

/** @type Config */
const DEFAULT_CONFIG = Object.freeze({
	rules: {valid: true},
	ignore: [],
	fixtures: undefined,
});

/**
 * Normalizes a user-provided RulesConfig into a NormalizedRules.
 * Figures out which rules should be kept, and calls their generator with the
 *   user-provided config. The returned function is the actual linting func.
 * @param {RulesConfig} rulesConfig The user-provided config
 * @returns {Promise<NormalizedRules>} Resolves to the normalized rules
 */
async function normalizeRules(rulesConfig) {
	/** @type {NormalizedRules} */
	const outp = {};
	const promises = Object.keys(rulesConfig)
		// Make sure no disabled rules are allowed in
		.filter((k) => rulesConfig[k] !== false)
		// Then convert each rule config into a rule func
		.map(async (ruleName) => {
			/** @type {RuleModule} */
			let loadedRule;
			try {
				loadedRule = await ruleLoader(ruleName);
			} catch {
				logger$4.warn(`Unknown rule "${ruleName}".`);
				return;
			}

			// Handle the case where there are multiple configs for a single rule
			const config = rulesConfig[ruleName];
			outp[ruleName] = Array.isArray(config)
				? config.map((config) => loadedRule.generate(config))
				: loadedRule.generate(config);
		});
	await Promise.all(promises);
	return outp;
}

/**
 * Normalizes a user-provided config to make sure it has every property we need.
 * Also handles merging with defaults.
 * @param {Config} config The user-provided config
 * @returns {Promise<NormalizedConfig>} Resolves to the normalized config
 */
async function normalizeConfig(config) {
	const defaulted = {
		...DEFAULT_CONFIG,
		...config,
	};
	defaulted.rules = {
		...DEFAULT_CONFIG.rules,
		...defaulted.rules,
	};
	/** @type NormalizedConfig */
	const outp = {
		rules: await normalizeRules(defaulted.rules),
		ignore: defaulted.ignore,
		fixtures: defaulted.fixtures,
	};
	return outp;
}

/**
 * The main function. Lints the provided AST using the user-provided config.
 * @param {String} file The file we are linting
 * @param {AST} ast The AST to lint
 * @param {Config} config The user-provided config to lint by
 * @returns {Promise<Linting>} Resolves to the linting that represents the result
 */
async function lint(file, ast, config) {
	if (ast.length === 0 && ast.source.trim() !== '') {
		throw new Error(`Unable to parse SVG from ${file || 'API'}:
${ast.source}`);
	}

	const config_ = await normalizeConfig(config);
	return new Linting(file, ast, config_.rules, config_.fixtures);
}

const svglint = {
	/**
	 * Lints a single SVG string.
	 * The function returns before the Linting is finished.
	 * You should listen to Linting.on("done") to wait for the result.
	 * @param {String} source The SVG to lint
	 * @param {Config} [config={}] The config to lint by
	 * @return {Promise<Linting>} Resolves to the Linting that represents the result
	 */
	async lintSource(source, config = {}) {
		const ast = parseSource(source);
		return lint(null, ast, config);
	},

	/**
	 * Lints a single file.
	 * The returned Promise resolves before the Linting is finished.
	 * You should listen to Linting.on("done") to wait for the result.
	 * @param {String} file The file path to lint
	 * @param {Config} [config={}] The config to lint by
	 * @returns {Promise<Linting>} Resolves to the Linting that represents the result
	 */
	async lintFile(file, config = {}) {
		const ast = await parseFile(file);
		return lint(file, ast, config);
	},

	// API used only by the CLI to avoid recreating config objects

	async lintFileWithNormalizedConfig(file, config) {
		const ast = await parseFile(file);
		if (ast.length === 0 && ast.source.trim() !== '') {
			throw new Error(`Unable to parse SVG from ${file}: ${ast.source}`);
		}

		return new Linting(file, ast, config.rules, config.fixtures);
	},

	async lintSourceWithNormalizedConfig(source, config) {
		const ast = await parseSource(source);
		if (ast.length === 0 && ast.source.trim() !== '') {
			throw new Error(`Unable to parse SVG from API: ${ast.source}`);
		}

		return new Linting(null, ast, config.rules, config.fixtures);
	},
};

const logger$3 = Logger('rule:attr');

/** @typedef {import('cheerio').Cheerio<import('domhandler').Document>} Cheerio */
/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */

/**
 * @typedef {Object<string,string|string[]|boolean|RegExp>} AttrConfig
 *
 * The key represents the attribute name. The value has the following meanings:
 * - `{Boolean}` If true, the attr must exist. If false, it must not exist.
 * - `{String}` The attr value must match this exactly. It must also exist.
 * - `{RegExp}` The attr value must match the regex.
 * - `{Array<String>}` The attr value must be one of these. It must also exist.
 *
 * The following special configs are allowed:
 * - `{ "rule::selector": {String} }` Default "*". The matching elements must fulfill the other configs.
 * - `{ "rule::whitelist": {Boolean} }` Default `false`. If true, no other attributes can exist than those specified by the other configs.
 * - `{ "rule::order": {Array<String> | Boolean} }` Default `null`. As array, attributes must be defined in the provided order. As `true`, attributes must be defined in alphabetical order.
 * - `{ "<attribute>?": {Boolean|String|RegExp|Array<String>} }` Appending a `?` to an attribute name will make that attribute optional, and it will not error if it is missing when `rule::whitelist` is set.
 */

/**
 * Workflow:
 * 1. Find all elements matching the selector.
 * 2. For each element:
 *   - Go through every rule in the config
 *	 - If their attribute must exist, check that it does
 *   - Go through every attribute on the element
 *	 - If it has a config:
 *	   - If allowed, remove it from the attr list
 *	   - If disallowed, error and remove it from the attr list
 *   - If whitelist is true, error if there are non-optional attributes left
 */

const SPECIAL_ATTRIBS = new Set([
	'rule::selector',
	'rule::whitelist',
	'rule::order',
]);

const OPTIONAL_SUFFIX = '?';

const isAttributeOptional = (attribute) => attribute.endsWith(OPTIONAL_SUFFIX);

/**
 * Executes on a single element.
 * @param {Cheerio} $elm The cheerio element to execute on
 * @param {AttrConfig} config The config to execute
 * @param {Reporter} reporter The rule reporter
 * @param {AST} ast The AST we are executing on
 */
// eslint-disable-next-line complexity
function executeOnElm($elm, config, reporter, ast) {
	// @ts-ignore
	const attributes_ = {...$elm.attribs};
	// Check that all attributes that must exist do so
	for (const attrib of Object.keys(config)) {
		// Do nothing with special configs
		if (SPECIAL_ATTRIBS.has(attrib)) {
			continue;
		}

		// Do nothing with optional attributes
		if (isAttributeOptional(attrib)) {
			continue;
		}

		// If defined and not false it must exist
		if (config[attrib] && !(attrib in attributes_)) {
			reporter.error(
				`Expected attribute '${attrib}', didn't find it`,
				$elm,
				ast,
			);
		}
	}

	if (config['rule::order']) {
		const attributes = Object.keys(attributes_);
		if (attributes.length > 0) {
			let order;
			if (config['rule::order'] === true) {
				// Alphabetical ordering
				order = [...attributes];
				order.sort();
			} else {
				order = config['rule::order'];
			}

			let previousIndex = order.indexOf(attributes[0]);
			for (let i = 1; i < attributes.length; i++) {
				const index = order.indexOf(attributes[i]);
				if (index === -1) {
					// This attribute doesn't need ordering, ignore it
					return;
				}

				if (previousIndex !== -1 && index < previousIndex) {
					reporter.error(
						`Wrong ordering of attributes, found "${attributes.join(
							', ',
						)}", expected "${order.join(', ')}"`,
						$elm,
						ast,
					);
					break;
				}

				previousIndex = index;
			}
		}
	}

	// Check that all configs are met
	for (const attrib of Object.keys(attributes_)) {
		const value = attributes_[attrib];
		const expected =
			config[attrib] === undefined
				? config[`${attrib}${OPTIONAL_SUFFIX}`]
				: config[attrib];
		let handled = false;
		// Check each type
		// eslint-disable-next-line default-case
		switch (typeof expected) {
			case 'boolean': {
				handled = true;
				if (expected === false) {
					reporter.error(`Attribute '${attrib}' is disallowed`, $elm, ast);
				}

				break;
			}

			case 'string': {
				handled = true;
				if (value !== expected) {
					reporter.error(
						`Expected attribute '${attrib}' to be "${expected}", was "${value}"`,
						$elm,
						ast,
					);
				}

				break;
			}

			case 'object': {
				if (Array.isArray(expected)) {
					handled = true;
					if (!expected.includes(value)) {
						reporter.error(
							`Expected attribute '${attrib}' to be one of ${JSON.stringify(
								expected,
							)}, was "${value}"`,
							$elm,
							ast,
						);
					}
				} else if (expected instanceof RegExp) {
					handled = true;
					if (!expected.test(value)) {
						reporter.error(
							`Expected attribute '${attrib}' to match ${expected}, was "${value}"`,
							$elm,
							ast,
						);
					}
				} else {
					reporter.warn(
						`Unknown config for attribute '${attrib}' (${JSON.stringify(
							expected,
						)}), ignoring`,
						$elm,
						ast,
					);
				}

				break;
			}
		}

		// If we handled the attribute (i.e. we had a config for it)
		// then remove it from our attribute list
		if (handled) {
			delete attributes_[attrib];
		}
	}

	if (config['rule::whitelist']) {
		const remaining = Object.keys(attributes_).filter(
			(attribute) => !isAttributeOptional(attribute),
		);

		if (remaining.length > 0) {
			reporter.error(
				`Found extra attributes ${JSON.stringify(remaining)} with whitelisting enabled`,
				$elm,
				ast,
			);
		}
	}
}

const attribute = {
	/**
	 * Generates a linting function from a config
	 * @param {AttrConfig} config
	 */
	generate(config) {
		/**
		 * Performs the linting according to the previously passed config.
		 * @param {Reporter} reporter The reporter to report warnings/errors to
		 * @param {Cheerio} $ A cheerio representation of the document
		 * @param {AST} ast The underlying AST representation of the document.
		 *				  This should be given to Reporter when warning/erroring with a node.
		 */
		return function (reporter, $, ast) {
			logger$3.debug('Called', config);

			// Find all elements that match the selector and execute on them
			const selector = config['rule::selector'] || '*';
			const $elms = $.find(selector).toArray();
			logger$3.debug('Found elms for selector', selector, $elms.length);
			for (const $elm of $elms) {
				executeOnElm($elm, config, reporter, ast);
			}
		};
	},
};

var attr = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: attribute
});

const logger$2 = Logger('rule:custom');

/** @typedef {import('cheerio').Cheerio<import('domhandler').Document>} Cheerio */
/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */
/** @typedef {{ filepath: string, fixtures: any }} Info */

/**
 * @callback CustomRule
 * @param {Reporter} reporter The reporter to report to
 * @param {Cheerio} $ A cheerio representation of the document
 * @param {AST} ast The AST of the document, which we should pass to reporter
 * @param {Info} info Info related to the current file being linted
 */
/**
 * @typedef {CustomRule} CustomConfig
 * The function will be executed as if though it was a rule.
 */

const custom = {
	/**
	 * Generates a linting function from a config
	 * @param {CustomConfig} config
	 */
	generate(config) {
		/**
		 * Performs the linting according to the previously passed config.
		 * @param {Reporter} reporter The reporter to report warnings/errors to
		 * @param {Cheerio} $ A cheerio representation of the document
		 * @param {AST} ast The underlying AST representation of the document.
		 *                  This should be given to Reporter when warning/erroring with a node.
		 * @param {Info} info Info related to the current file being linted.
		 */
		return function (reporter, $, ast, info) {
			logger$2.debug('Called', config);
			return config(reporter, $, ast, info);
		};
	},
};

var custom$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: custom
});

const logger$1 = Logger('rule:elm');

/** @typedef {import('cheerio').Cheerio<import('domhandler').Document>} Cheerio */
/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */

/**
 * @typedef {Object<string,Boolean|Number|Array<Number>>} ElmConfig
 * The key is used as selector. The value has the following meanings:
 * - `{Boolean}` If true the selector must be matched. If false the selector must not be matched.
 * - `{Number}` The number of elements the selector must resolve to. Must be exact.
 * - `{Array<Number>}` The number of elements the selector resolves to must be between the first and the second number.
 *
 * Note that if an element is disallowed by one rule, but allowed by another, it will be allowed.
 * This allows you to do e.g. `{ "title": false, "svg > title": true }`.
 */
/**
 * @typedef RuleElmResult
 * @property {Node} [elm] The element the result relates to
 * @property {String} message The message the result is described by
 */
/**
 * @typedef RuleExecution
 * @property {RuleElmResult[]} allowed The elements allowed by the rule
 * @property {RuleElmResult[]} disallowed The elements disallowed by the rule
 */

/**
 * Workflow:
 * 1. Find all { allowed: [], disallowed: [] }
 * 2. Filter .disallowed by not in .allowed
 * 3. If .disallowed.length, fail
 *
 * Rules act like this:
 * - {true} If found, put in allowed
 * - {false} If found, put in disallowed
 * - {Number} If exact match, put all in allowed. If not, put all in disallowed.
 * - {Array<Number>} If match, put all in allowed. If not, put all in disallowed.
 *
 * This means that e.g. `{ "b": 2, "a > b": true}` with "<b/><b/><a><b/><b/></a>"
 * will fail, which is something to keep in mind.
 */

/**
 * Executes a rule, returning the RuleExecution.
 * @param {String} selector The selector of the rule
 * @param {Boolean|Number|Array<Number>} config The config of the rule
 * @param {Cheerio} $ The cheerio representation of the document
 */
function executeRule(selector, config, $) {
	/** @type {RuleExecution} */
	const outp = {
		allowed: [],
		disallowed: [],
	};
	/** @type {RuleElmResult[]} */
	const matches = $.find(selector)
		.toArray()
		.map((elm) => ({elm, message: ''}));
	let allowed = null;
	let message = null;
	switch (typeof config) {
		case 'boolean': {
			if (config) {
				allowed = true;
				if (matches.length === 0) {
					outp.disallowed.push({
						elm: null,
						message: `Expected '${selector}', none found`,
					});
				}
			} else {
				allowed = false;
				message = 'Element disallowed';
			}

			break;
		}

		case 'number': {
			if (matches.length === config) {
				allowed = true;
			} else {
				allowed = false;
				message = `Found ${matches.length} elements for '${selector}', expected ${config}`;
				if (matches.length === 0) {
					matches.push({elm: null, message: ''});
				}
			}

			break;
		}

		default: {
			if (
				Array.isArray(config) &&
				config.length === 2 &&
				typeof config[0] === 'number' &&
				typeof config[1] === 'number'
			) {
				if (matches.length >= config[0] && matches.length <= config[1]) {
					allowed = true;
				} else {
					outp.disallowed.push({
						elm: null,
						message: `Found ${matches.length} elements for '${selector}', expected between ${config[0]} and ${config[1]}`,
					});
				}
			} else {
				// eslint-disable-next-line no-throw-literal
				throw `Unknown config type '${typeof config}' (${JSON.stringify(config)})`;
			}
		}
	}

	if (allowed === true) {
		// eslint-disable-next-line unicorn/prefer-spread
		outp.allowed = outp.allowed.concat(matches);
	} else if (allowed === false) {
		// eslint-disable-next-line unicorn/prefer-spread
		outp.disallowed = outp.disallowed.concat(
			matches.map((match) => {
				match.message = message;
				return match;
			}),
		);
	}

	return outp;
}

const elm = {
	/**
	 * Generates a linting function from a config
	 * @param {ElmConfig} config
	 */
	generate(config) {
		/**
		 * Performs the linting according to the previously passed config.
		 * @param {Reporter} reporter The reporter to report warnings/errors to
		 * @param {Cheerio} $ A cheerio representation of the document
		 * @param {AST} ast The underlying AST representation of the document.
		 *                  This should be given to Reporter when warning/erroring with a node.
		 */
		return function (reporter, $, ast) {
			logger$1.debug('Called', config);
			// Gather the result of every execution
			const executions = Object.keys(config)
				.map((selector) => {
					try {
						return executeRule(selector, config[selector], $);
					} catch (error) {
						if (error instanceof Error) {
							reporter.exception(error);
						} else {
							reporter.warn(`Rule '${selector}' failed to lint: ${error}`);
						}

						return null;
					}
				})
				.filter(Boolean);
			// Then filter out the disallowed elms that are allowed elsewhere
			/** @type {Node[]} */
			const allowedElms = [];
			/** @type {RuleElmResult[]} */
			const disallowed = [];
			// First gather the allowed elms
			for (const execution of executions) {
				allowedElms.push(...execution.allowed.map((result) => result.elm));
			}

			// The filter the disallowed elms by whether they are allowed elsewhere
			for (const execution of executions) {
				disallowed.push(
					...execution.disallowed.filter(
						(result) => !allowedElms.includes(result.elm),
					),
				);
			}

			// Finally report all the remaining disallowed elms
			for (const result of disallowed) {
				reporter.error(result.message, result.elm, ast);
			}
		};
	},
};

var elm$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: elm
});

const logger = Logger('rule:valid');

/** @typedef {import('cheerio').Cheerio<import('domhandler').Document>} Cheerio */
/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */

/**
 * Workflow:
 * 1. Validate the SVG using fast-xml-parser
 * 2. If the SVG is not valid, report an error
 */

const valid = {
	/**
	 * Generates a linting function from a config
	 * @param {Boolean} config
	 */
	generate(enabled) {
		/**
		 * Performs the linting according to the previously passed config.
		 * @param {Reporter} reporter The reporter to report warnings/errors to
		 * @param {Cheerio} $ A cheerio representation of the document
		 * @param {AST} ast The underlying AST representation of the document.
		 *                  This should be given to Reporter when warning/erroring with a node.
		 */
		return function (reporter, $, ast) {
			logger.debug('Called', enabled);
			if (!enabled) {
				return;
			}

			if (!ast.source) {
				logger.debug('Encountered empty SVG. Considering valid');
				return;
			}

			const result = fastXmlParser.XMLValidator.validate(ast.source);
			if (result !== true) {
				reporter.error(result.err.msg, null, ast);
			}
		};
	},
};

var valid$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: valid
});

exports.default = svglint;
exports.normalizeConfig = normalizeConfig;
