'use strict';

var node_path = require('node:path');
var isUtf8 = require('is-utf8');
var jstransformer = require('jstransformer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return n;
}

var isUtf8__default = /*#__PURE__*/_interopDefaultLegacy(isUtf8);
var jstransformer__default = /*#__PURE__*/_interopDefaultLegacy(jstransformer);

/**
 * Parse a filepath into dirname, base & extensions
 * @param {string} filename
 */
function parseFilepath(filename) {
  const isNested = filename.includes(node_path.sep);
  const dir = isNested ? node_path.dirname(filename) : '';
  const [base, ...extensions] = node_path.basename(filename).split('.');
  return {
    dirname: dir,
    base,
    extensions
  };
}

/**
 * @param {string} filename
 * @param {string} extname
 * @returns {string}
 */
function handleExtname(filename, extname) {
  const {
    dirname,
    base,
    extensions
  } = parseFilepath(filename);
  const e = extname && extname.slice(1);
  if (!e || e !== extensions[extensions.length - 1]) {
    extensions.pop();
    if (e) extensions.push(e);
  }
  return [node_path.join(dirname, base), ...extensions].join('.');
}

/**
 * Get a transformer by name ("jstransformer-ejs"), shortened name ("ejs") or filesystem path
 * @param {string|import('./index').JsTransformer} namePathOrTransformer
 * @param {import('metalsmith').Debugger} debug
 * @returns {Promise<import('./index').JsTransformer>}
 */
function getTransformer(namePathOrTransformer, debug) {
  let transform = null;
  const t = namePathOrTransformer;
  const tName = t;
  const tPath = t;

  // let the jstransformer constructor throw errors
  if (typeof t !== 'string') {
    transform = Promise.resolve(t);
  } else {
    if (node_path.isAbsolute(tPath) || tPath.startsWith('.') || tName.startsWith('jstransformer-')) {
      debug('Importing transformer: %s', tPath);
      transform = (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(tPath).then(t => t.default);
    } else {
      debug('Importing transformer: jstransformer-%s', tName);
      // suppose a shorthand where the jstransformer- prefix is omitted, more likely
      transform = (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(`jstransformer-${tName}`).then(t => t.default).catch(() => {
        // else fall back to trying to import the name
        debug.warn('"jstransformer-%s" not found, trying "%s" instead', tName, tName);
        return (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(tName).then(t => t.default);
      });
    }
  }
  return transform.then(jstransformer__default["default"]);
}

/* c8 ignore next 3 */
let debug = () => {
  throw new Error('uninstantiated debug');
};

/**
 * @callback Render
 * @param {string} source
 * @param {Object} options
 * @param {Object} locals
 * @returns {string}
 */

/**
 * @callback RenderAsync
 * @param {string} source
 * @param {Object} options
 * @param {Object} locals
 * @param {Function} callback
 * @returns {Promise<string>}
 */

/**
 * @callback Compile
 * @param {string} source
 * @param {Object} options
 * @returns {string}
 */

/**
 * @callback CompileAsync
 * @param {string} source
 * @param {Object} options
 * @param {Function} callback
 * @returns {Promise<string>}
 */

/**
 * @typedef {Object} JsTransformer
 * @property {string} name
 * @property {string[]} inputFormats
 * @property {string} outputFormat
 * @property {Render} [render]
 * @property {RenderAsync} [renderAsync]
 * @property {Compile} [compile]
 * @property {CompileAsync} [compileAsync]
 */

/**
 * @typedef {Object} Options `@metalsmith/layouts` options
 * @property {string|JsTransformer} transform Jstransformer to run: name of a node module or local JS module path (starting with `.`) whose default export is a jstransformer. As a shorthand for existing transformers you can remove the `jstransformer-` prefix: `marked` will be understood as `jstransformer-marked`. Or an actual jstransformer; an object with `name`, `inputFormats`,`outputFormat`, and at least one of the render methods `render`, `renderAsync`, `compile` or `compileAsync` described in the [jstransformer API docs](https://github.com/jstransformers/jstransformer#api)
 * @property {string} [default=null] A default layout to apply to files, eg `default.njk`.
 * @property {string|string[]} [pattern='**'] Only files that match this pattern will be processed. Accepts a string or an array of strings. The default is `**` (all).
 * @property {string} [directory='layouts'] The directory for the layouts. The default is `layouts`.
 * @property {Object} [engineOptions] Pass options to [the jstransformer](https://github.com/jstransformers/jstransformer) that's rendering your layouts. The default is `{}`.
 * @property {string} [extname] Pass `''` to remove the extension or `'.<extname>'` to keep or rename it. By default the extension is kept
 */

/**
 * Set default options based on jstransformer `transform`
 * @param {JsTransformer} transform
 * @returns {Options}
 */
function normalizeOptions(options, transform) {
  const inputFormats = Array.isArray(transform.inputFormats) ? transform.inputFormats : [transform.inputFormats];
  return {
    default: null,
    pattern: `**/*.{${inputFormats.join(',')}}`,
    directory: 'layouts',
    engineOptions: {},
    extname: `.${transform.outputFormat}`,
    ...options,
    transform: {
      ...transform,
      inputFormats
    }
  };
}

/**
 * Engine, renders file with the appropriate layout
 */

function render({
  filename,
  files,
  metalsmith,
  options,
  transform
}) {
  const file = files[filename];
  debug.info('Rendering "%s" with layout "%s"', filename, file.layout);
  const metadata = metalsmith.metadata();
  // Stringify file contents
  const contents = file.contents.toString();
  const locals = {
    ...metadata,
    ...file,
    contents
  };
  const layoutPath = node_path.join(metalsmith.path(options.directory), file.layout);

  // Transform the contents
  return transform.renderFileAsync(layoutPath, options.engineOptions, locals).then(rendered => {
    debug('Done rendering "%s"', filename);

    // move file if necessary
    const newName = handleExtname(filename, options.extname);
    if (newName !== filename) {
      debug('Renaming "%s" to "%s"', filename, newName);
      delete files[filename];
      files[newName] = file;
    }
    // Update file with results
    file.contents = Buffer.from(rendered.body);
  }).catch(err => {
    // Prepend error message with file path
    err.message = `${filename}: ${err.message}`;
    throw err;
  });
}

/**
 * A metalsmith plugin for rendering layouts
 * @param {Options} options
 * @returns {import('metalsmith').Plugin}
 */
function layouts(options) {
  let transform;
  return async function layouts(files, metalsmith, done) {
    debug = metalsmith.debug('@metalsmith/layouts');
    if (!options.transform) {
      done(new Error('"transform" option is required'));
      return;
    }

    // Check whether the pattern option is valid
    if (options.pattern && !(typeof options.pattern === 'string' || Array.isArray(options.pattern))) {
      return done(new Error('invalid pattern, the pattern option should be a string or array of strings.'));
    }

    // skip resolving the transform option on repeat runs
    if (!transform) {
      try {
        transform = await getTransformer(options.transform, debug);
      } catch (err) {
        // pass through jstransformer & Node import resolution errors
        return done(err);
      }
    }
    options = normalizeOptions(options, transform);
    debug('Running with options %O', options);
    let matches = metalsmith.match(options.pattern, Object.keys(files));

    // skip non-utf8 & invalid layout files
    matches = matches.filter(fpath => {
      const f = files[fpath];
      const absPath = metalsmith.path(fpath);
      if (!isUtf8__default["default"](f.contents)) {
        debug.warn('Skipping file "%s": non utf-8 content', absPath);
        return false;
      }
      if (!f.layout) {
        if (options.default && !Reflect.has(f, 'layout')) {
          f.layout = options.default;
          return true;
        }
        debug.warn('Skipping file "%s": %s', absPath, f.layout === false ? 'layout: false' : 'layout: undefined');
        return false;
      } else if (!options.transform.inputFormats.includes(node_path.extname(f.layout).slice(1))) {
        debug.info('Skipping file "%s": layout "%s" does not match inputFormats ["%s"]', absPath, f.layout, options.transform.inputFormats.join(', '));
        return false;
      }
      return true;
    });

    // allow omitting the .<ext> part of a layout if it matches transform.inputFormats[0]
    matches.forEach(fpath => {
      const f = files[fpath];
      debug(f.layout);
      if (!node_path.extname(f.layout)) {
        f.layout = `${f.layout}.${options.transform.inputFormats[0]}`;
      }
    });

    // Let the user know when there are no files to process
    if (!matches.length) {
      debug.warn('No valid files to process.');
      return done();
    }

    // Map all files that should be processed to an array of promises and call done when finished
    return Promise.all(matches.map(filename => render({
      filename,
      files,
      metalsmith,
      options,
      transform
    }))).then(() => {
      debug('Done rendering %s file%s', matches.length, matches.length > 1 ? 's' : '');
      done();
    }).catch(done);
  };
}

module.exports = layouts;
